import { Mat4, Vec2, Vec4 } from "@vicimpa/glm";
import Engine from "../engine.ts";
import { Node3D } from "../node.ts";
import { Skybox } from "./skybox.ts";
import { Model } from "../graphics/assets/model.ts";
import { CubeMapTexture } from "../graphics/assets/texture.ts";

export class Object3D extends Node3D {
    model:Model;

    constructor(engine:Engine, name:string, model:Model) {
        super(engine, name);
        this.model = model;
    }
    
    render_class(view_matrix: Mat4, projection_matrix_3d: Mat4, projection_matrix_2d: Mat4, time:number, delta_time:number): void {        
        this.model.draw_start();
        
        this.on_render(this, this.engine, time, delta_time);

        const gm = this.engine.graphics_manager;

        const skybox = this.get_parent_of_type(Skybox);
        if (skybox)
            gm.set_uniform("environment.ambient_light", skybox.ambient_light);

        const main_camera_3d = this.engine.main_scene.main_camera_3d

        // CAMERA POS
        if (main_camera_3d) {
            gm.set_uniform("camera_position", main_camera_3d.position);
        } else {
            throw Error(`Main scene "${this.engine.main_scene.name}" does not have a main_camera_3d set which is required to render Object3Ds such as the node named "${this.name}".`);
        }

        // PASS IN LIGHTS
        const point_lights = gm.point_lights;
        const spot_lights = gm.spot_lights;
        const directional_lights = gm.directional_lights;

        const point_lights_count = point_lights.length;
        const spot_lights_count = spot_lights.length;
        const directional_lights_count = directional_lights.length;

        const n = Math.max(
            point_lights_count,
            spot_lights_count,
            directional_lights_count
        )

        var mesh_size = this.model.mesh.dimensions.clone().mul(this.scale).length();

        var local_mesh_center = this.model.mesh.center;
        var mesh_center = new Vec4(local_mesh_center.x, local_mesh_center.y, local_mesh_center.z, 1.0).applyMat4(this.get_world_matrix())

        for (var i = 0; i < n; ++i) {
            if (i < point_lights_count) {
                const light = point_lights[i];
                if (mesh_center.xyz.distance(light.position) - mesh_size / 2.0 < light.range)
                    light.set_uniforms("point_lights", i);
            }
            if (i < spot_lights_count)
                spot_lights[i].set_uniforms("spot_lights", i);
            if (i < directional_lights_count)
                directional_lights[i].set_uniforms("directional_lights", i);
        }

        gm.set_uniform("point_lights_count", point_lights_count);
        gm.set_uniform("spot_lights_count", spot_lights_count);
        gm.set_uniform("directional_lights_count", directional_lights_count);

        //PASS SHADOW MAPS
        gm.set_uniform("directional_light_shadow_maps", gm.directional_light_shadow_map_texture)
        gm.set_uniform("point_light_shadow_maps", gm.point_light_shadow_map_texture)
        gm.set_uniform("shadow_map_size", new Vec2(gm.shadow_resolution))

        // pass the MVP matrix
        gm.set_uniform("u_model", this.get_world_matrix());

        gm.set_uniform("u_view", view_matrix);

        gm.set_uniform("u_projection", projection_matrix_3d);

        this.model.draw_end();
    }
}